import BaseWriter from '../writer.js';
import * as docutils from '../index.js';
import * as nodes from '../nodes.js';
import * as utils from '../utils.js';

import { Document, NodeClass, NodeInterface, SettingsSpecType } from "../types.js";
import { Settings } from "../settings.js";
import { InvalidStateError } from "../exceptions.js";
import * as xmlSaxSaxutils from '../xml-escape.js';

class XMLTranslator extends nodes.GenericNodeVisitor {
    public output: string[];
    private indent: string;
    private warn: (...args: any[]) => NodeInterface;
    private error: (...args: any[]) => NodeInterface;
    private settings: Settings;
    private newline: string;
    private level: number;
    private inSimple: number;
    private fixedText: number;
    private simple_nodes: NodeClass[] = [];
    private doctype: string = '<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">\n';
    private generator: string = '<!-- Generated by Docutils ' + docutils.__version__ + ' -->\n';

    public constructor(document: Document) {
        super(document);
        this.document = document;

        // Reporter
        this.warn = this.document.reporter.warning;
        this.error = this.document.reporter.error;

        // Settings
        this.settings = document.settings;
        this.indent = this.newline = '';
        if (this.settings.newlines) {
            this.newline = '\n';
        }
        if (this.settings.indents) {
            this.newline = '\n';
            this.indent = '    ';  // TODO make this configurable?
        }
        this.level = 0;       // indentation level
        this.inSimple = 0;   // level of nesting inside mixed-content elements
        this.fixedText = 0;  // level of nesting inside FixedText elements

        // Output
        this.output = [];
        if (this.settings.xmlDeclaration && this.settings.outputEncoding !== undefined) {
            this.output.push(utils.xmlDeclaration(this.settings.outputEncoding));
        }
        if (this.settings.doctypeDeclaration) {
            this.output.push(this.doctype);
        }
        this.output.push(this.generator);

        // initialize XML parser (if needed)
        // TODO: Implement XML parser initialization if required
        // this.theHandle = new TestXml();
        // this.xmlparser.setContentHandler(this.theHandle);
    }

    public default_visit(node: NodeInterface): void {
        this.simple_nodes = [nodes.TextElement];// nodes.image, nodes.colspec, nodes.transition]
        if (!this.inSimple) {
            this.output.push(Array(this.level + 1).join(this.indent));
        }
        this.output.push(node.starttag(xmlSaxSaxutils.quoteattr));
        if (!(node instanceof nodes.Inline)) {
            this.level += 1;
        }
        // fixme should probably pick this code up
        if (node instanceof nodes.FixedTextElement || node instanceof nodes.literal) {
            this.fixedText += 1;
        }
        if (this.simple_nodes.findIndex((nt: NodeClass): boolean => node instanceof nt) !== -1) {
            this.inSimple++;
        }
        if (!this.inSimple) {
            this.output.push(this.newline);
        }
    }

    public default_departure(node: NodeInterface): void {
        if (!(node instanceof nodes.Inline)) {
            this.level -= 1;
        }
        if (!this.inSimple) {
            this.output.push(this.indent.repeat(this.level));
        }
        this.output.push(node.endtag());
        if (node instanceof nodes.FixedTextElement || node instanceof nodes.literal) {
            this.fixedText -= 1;
        }
        if (this.simple_nodes.findIndex((nt: NodeClass): boolean => node instanceof nt) !== -1) {
            this.inSimple -= 1;
        }
        if (!this.inSimple) {
            this.output.push(this.newline);
        }
    }

    public visit_Text(node: NodeInterface): void {
        let text = xmlSaxSaxutils.escape(node.astext());
        // Indent text if we are not in a FixedText element:
        if (!this.fixedText) {
            text = text.replace(/\n/g, '\n' + this.indent.repeat(this.level));
        }
        this.output.push(text);
    }

    public depart_Text(node: NodeInterface): void {
        // pass
    }

}

export default class XMLWriter extends BaseWriter {
    private visitor?: XMLTranslator;
    private translatorClass: typeof XMLTranslator = XMLTranslator;

    public settingsSpec: SettingsSpecType[] = [
        [
            '"Docutils XML" Writer Options',
            null,
            [
                [
                    'Generate XML with newlines before and after tags.',
                    [
                        '--newlines'
                    ],
                    {
                        action: 'store_true',
                        validator: 'frontend.validate_boolean'
                    }
                ],
                [
                    'Generate XML with indents and newlines.',
                    [
                        '--indents'
                    ], // #@ TODO use integer value for number of spaces?

                    {
                        action: 'store_true',
                        validator: 'frontend.validate_boolean'
                    }
                ],
                [
                    'Omit the XML declaration.  Use with caution.',
                    [
                        '--no-xml-declaration'
                    ],
                    {
                        dest: 'xml_declaration',
                        default: 1,
                        action: 'store_false',
                        validator: 'frontend.validate_boolean',
                    }
                ],
                [
                    'Omit the DOCTYPE declaration.',
                    [
                        '--no-doctype'
                    ],
                    {
                        dest: 'doctype_declaration',
                        default: 1,
                        action: 'store_false',
                        validator: 'frontend.validate_boolean',
                    }
                ]
            ]
        ]
    ];

    public translate(): void | never {
        if (this.document === undefined) {
            throw new InvalidStateError('No document');
        }
        const TranslatorClass = this.translatorClass;

        const visitor = new TranslatorClass(this.document);
        this.visitor = visitor;
        this.document.walkabout(visitor);

        this.output = visitor.output.join('');

    }
}

export { XMLWriter };
